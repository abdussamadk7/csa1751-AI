from collections import deque

def Solution(a, b, target):
    m = {}  # To store visited states
    isSolvable = False
    path = []

    # Queue to perform BFS
    q = deque()

    # Initializing with jugs being empty
    q.append((0, 0))

    while q:
        # Current state
        u = q.popleft()

        # Skip if already visited
        if (u[0], u[1]) in m:
            continue

        # If any of the jugs have more water than their capacity, skip the state
        if u[0] > a or u[1] > b or u[0] < 0 or u[1] < 0:
            continue

        # Mark the state as visited
        path.append([u[0], u[1]])
        m[(u[0], u[1])] = 1

        # Check if the solution is found
        if u[0] == target or u[1] == target:
            isSolvable = True

            # If we reached the target, ensure one of the jugs is emptied
            if u[0] == target and u[1] != 0:
                path.append([u[0], 0])
            elif u[1] == target and u[0] != 0:
                path.append([0, u[1]])

            # Print the solution path
            for p in path:
                print(f"({p[0]}, {p[1]})")
            break

        # Generate all possible next states

        # Fill Jug2
        q.append((u[0], b))

        # Fill Jug1
        q.append((a, u[1]))

        # Empty Jug2
        q.append((u[0], 0))

        # Empty Jug1
        q.append((0, u[1]))

        # Pour water from Jug2 to Jug1
        pour = min(u[1], a - u[0])
        q.append((u[0] + pour, u[1] - pour))

        # Pour water from Jug1 to Jug2
        pour = min(u[0], b - u[1])
        q.append((u[0] - pour, u[1] + pour))

    if not isSolvable:
        print("Solution not possible")

if __name__ == '__main__':
    Jug1, Jug2, target = 4, 3, 2
    print("Path from initial state to solution state:")
    Solution(Jug1, Jug2, target)
